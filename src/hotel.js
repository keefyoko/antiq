// import { door } from './front/door.js'
// import { open } from './front/open.js'

// конфликт имён с таблицами внутренних свойств
// при table { deep: {} } не может существовать door table_deep

export default function hotel(door) {
  const teamMemberD = door('team_member', () => ({ name: '' }))

  const authorD = door('author', () => ({
    name: '',
    books: [bookD],
  }))

  const bookD = door(
    'book',
    () => ({
      team_member: teamMemberD,
      authors: [authorD],
      deep: {
        ea: '',
        very: {
          ea: '',
        },
      },
    }),
    // перед первым запросом на сервер нет никакой асинхронности
    // всё это можем записать в хук на следующем уровне

    {
      // нужно записывать, из каких методов какие поля каких сущностей получаются
      // в зависимости от этого делать ререндеры
      // useApi(book.one, 17)

      x: async () => {
        const first = await bookD.get(17)
        const second = await bookD.get(18)
        return [first, second]
      },

      y: async () => {
        const first = await bookD.get(19)
        const second = await bookD.get(20)
        return [first, second]
      },

      one: async (id) => {
        // нужно сделать так, что каждый раз когда выполняется функция внутри метода
        // все асинхронное на фронте должно быть записано вовне метода в хуки
        // и передаваться через аргументы
        // асинхронность бэка же обёрнута в функцию back
        // выполняется обёрнутая функция door

        // как понять, из какого метода вызывается апи?
        // апи-функция может вернуть promise

        // 1. метод обёрнут в g.eventId и door и вызываемый метод
        // 2. первое асинхронное апи знает эти переменные и отправляет их на сервер
        // 3. с сервера приходят все данные метода, он выполняется на фронте ?синхронно

        const book = await bookD.get(id)

        // console.log(id, book)
        // можем ли мы в асинхронный поток перед конкретным событием задать переменную?
        // обернуть выполнение кода события, поставив микротаск в очередь перед микротаском события

        // что если нужно что-то сделать с этой книгой?
        // if (user.id !== 'oki-doki') await updateViews(book.name)

        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        // все обращения к стороннему апи внутри ивентов делаются на стороне бэка
        // если нужны обращения к стороннему апи с фронта, делаем их в хуках
        // все нужные для обращения к стороннему апи данные фронта передаём в аргументы

        // на фронте есть сущности
        // они мутабельны, но не сразу на действие
        // хотя их изменения и приходят извне, производя ререндер
        // мы сохраняем изменения сущностей
        // и по ним отдаём самые свежие данные в хуки
        // изменяя данные при ответе сервера
        // ориентируемся, применять ли изменение поля
        // по времени изменения в бд
        // всё хранится в не-рекурсивном состоянии
        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        // перед продолжением выполнения метода делаем g.eventId

        // во время выполнения макротаска записывается очередь микротасков
        // микротаски выполняются после выполнения макротаска
        return book
      },

      // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      // !!!!!!!! в какой форме сохраняем запросы !!!!!!!!
      // фронт
      // нужно ли сохранять аргументы метода, или достаточно ивенты?
      // нужно и то, и другое
      // метод с аргументами - сохраняем для возвращения в useData
      // ивент с аргументами: синхронно возвращаем из get имеющееся значение, даже если оно было получено в другом методе

      // get-запросы по primary key не кэшируем отдельно, смотрим только наличие всех полей
      // у всех остальных get-запросов аргументы сохраняем и по ним ориентируемся
      // (todo) ужесточение фильтров фронтовыми силами, если есть все элементы

      // 1. методы из data с аргументами (methodName: { jsonArgs: result })
      // 2. get-запросы door (s/o-поля, аргументы) { door-method: { sortedQueryFields: { jsonArgs: result } } }
      // 3. если в get-аргументе primaryKey, то сущность с полями можем посмотреть в сторе
      // 4. во всех массивах только id
      // 5. граф normId: { methodName: { jsonArgs: true } }
      // 6. граф normId: { parentId: { pathsToChild: true } }
      // 7. граф normId: { childNormId: true }
      // 8. граф { normId: { door-method: { sortedQueryFields: true } } } - в каких методах закешированы сущности

      // если есть асинхронность (недостаток данных на фронте)
      // put, rm, первые get
      // она есть только один раз за метод
      // запоминаем get-запросы каждой сессии в методах для useData
      // то при изменении связанных get выполняем метод целиком на сервере
      // то есть по изменению условия get определяем, выполняем ли подключенный метод
      // отправляем результат на фронт
      // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      // if arg func cookie and rest
      authorsOfFavoriteBooks: async (pag, userId) => {
        // здесь в первый раз отправляется запрос на сервер
        // в нём authorsOfFavoriteBooks(pag, userId)
        // считаются все величины
        /* const favoriteBooksIds = await favoriteBooksD.s('id').get({
          user: userId,
        }) */
        // если где-то уже получались favoriteBooks
        // то может получались и booksAuthors с ними
        // и это действие можем выполнить тоже синхронно
        // а может и асинхронно - если не получались
        // поэтому нужен await
        /* const favoriteBooksAuthorsIds = await booksAuthorsD.s('author').get({
          id: any(favoriteBooksD.s('id').out({
            user: userId
          })),
        }) */
        /*
        return authorD.get(
          {
            id: any(
              booksAuthorsD.s('author').out({
                id: any(favoriteBooksD.s('id').out({
                  user: userId
                })),
              })
            ),
          },
          { pag }
        ) */
      },
    },
    {
      // в методе может быть несколько put
      // фронт:
      // put не возвращает promise, потому что уже есть вся информация для вычислений
      // при сетевой ошибке изменения всех put внутри метода стираются
      // для этого нужно передавать id вызова текущего апи-метода в put и rm

      // загрузка есть только у ивентов, методы - её асинхронные крупицы
      // в интерфейсе нельзя увидеть прогресс отдельных методов
      // Promise.all всех методов ивента - единственный слой загрузки для пользователя
      // в то же время, интерфейсом можно пользоваться при загрузке
      // ивенты внутри ивентов в плане загрузки превращаются в методы

      // на фронте put синхронен
      // но всё равно ставит лоадер на ивент
      upd: async (diff) => {
        return bookD.put(diff)
      },

      add: async () => {
        const book = bookD.put({
          team_member: null,
          authors: [],
          deep: { ea: 'valDeep', very: { ea: 'valVery' } },
        })
        console.log('book')
        return book
      },
    }
  )

  return bookD
}
